{
  "language": "Solidity",
  "sources": {
    "contracts/Web3RSVP.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ncontract Web3RSVP {\n    event NewEventCreated(\n        bytes32 eventID,\n        address creatorAddress,\n        uint256 eventTimestamp,\n        uint256 maxCapacity,\n        uint256 deposit,\n        string eventDataCID\n    );\n    event NewRSVP(bytes32 eventID, address attendeeAddress);\n    event ConfirmedAttendee(bytes32 eventID, address attendeeAddress);\n    event DepositsPaidOut(bytes32 eventID);\n\n    // Event\n    struct CreateEvent {\n        bytes32 eventId;\n        string eventDataCID;\n        address eventOwner;\n        uint256 eventTimestamp;\n        uint256 deposit;\n        uint256 maxCapacity;\n        address[] confirmedRSVPs;\n        address[] claimedRSVPs;\n        bool paidOut;\n    }\n\n    // Map from an ID to an Event\n    mapping(bytes32 => CreateEvent) public idToEvent;\n\n    // Create a new Event\n    function createNewEvent(\n        uint256 eventTimestamp,\n        uint256 deposit,\n        uint256 maxCapacity,\n        string calldata eventDataCID\n    ) external {\n        // Hash the variables we passed in to generate an unique ID: eventId\n        bytes32 eventId = keccak256(abi.encodePacked(msg.sender, address(this), eventTimestamp, deposit, maxCapacity));\n\n        // Make the id didn't already exist\n        require(idToEvent[eventId].eventTimestamp == 0, \"ALREADY REGISTERED\");\n\n        address[] memory confirmedRSVPs; // Users who RSVPâ€™d\n        address[] memory claimedRSVPs; // Users who check into the Event\n\n        // Creates a new Event by adding it to the mapping using 'eventId' as the key\n        idToEvent[eventId] = CreateEvent(\n            eventId,\n            eventDataCID,\n            msg.sender,\n            eventTimestamp,\n            deposit,\n            maxCapacity,\n            confirmedRSVPs,\n            claimedRSVPs,\n            false\n        );\n\n        emit NewEventCreated(eventId, msg.sender, eventTimestamp, maxCapacity, deposit, eventDataCID);\n    }\n\n    // Users RSVP to a created Event\n    function createNewRSVP(bytes32 eventId) external payable {\n        // look up event from our mapping\n        CreateEvent storage myEvent = idToEvent[eventId];\n\n        // require that the sending value is exactly equal to the 'CreateEvent' deposit\n        require(msg.value == myEvent.deposit, \"NOT ENOUGH\");\n\n        // require that the event hasn't already happened (<eventTimestamp)\n        require(block.timestamp <= myEvent.eventTimestamp, \"ALREADY HAPPENED\");\n\n        // make sure event is under max capacity\n        require(myEvent.confirmedRSVPs.length < myEvent.maxCapacity, \"This event has reached capacity\");\n\n        // require that msg.sender isn't already in myEvent.confirmedRSVPs AKA hasn't already RSVP'd\n        for (uint8 i = 0; i < myEvent.confirmedRSVPs.length; i++) {\n            require(myEvent.confirmedRSVPs[i] != msg.sender, \"ALREADY CONFIRMED\");\n        }\n\n        myEvent.confirmedRSVPs.push(payable(msg.sender));\n\n        emit NewRSVP(eventId, msg.sender);\n    }\n\n    // Owner check in the Users to an Event\n    function confirmAttendee(bytes32 eventId, address attendee) public {\n        // look up event from our struct using the eventId\n        CreateEvent storage myEvent = idToEvent[eventId];\n\n        // require that msg.sender is the owner of the event - only the host should be able to check people in\n        require(msg.sender == myEvent.eventOwner, \"NOT AUTHORIZED\");\n\n        // require that attendee trying to check in actually RSVP'd\n        address rsvpConfirm;\n\n        for (uint8 i = 0; i < myEvent.confirmedRSVPs.length; i++) {\n            if (myEvent.confirmedRSVPs[i] == attendee) {\n                rsvpConfirm = myEvent.confirmedRSVPs[i];\n            }\n        }\n\n        require(rsvpConfirm == attendee, \"NO RSVP TO CONFIRM\");\n\n        // require that attendee is NOT already in the claimedRSVPs list AKA make sure they haven't already checked in\n        for (uint8 i = 0; i < myEvent.claimedRSVPs.length; i++) {\n            require(myEvent.claimedRSVPs[i] != attendee, \"ALREADY CLAIMED\");\n        }\n\n        // require that deposits are not already claimed by the event owner\n        require(myEvent.paidOut == false, \"ALREADY PAID OUT\");\n\n        // add the attendee to the claimedRSVPs list\n        myEvent.claimedRSVPs.push(attendee);\n\n        // sending eth back to the staker `https://solidity-by-example.org/sending-ether`\n        (bool sent, ) = attendee.call{value: myEvent.deposit}(\"\");\n\n        // if this fails, remove the user from the array of claimed RSVPs\n        if (!sent) {\n            myEvent.claimedRSVPs.pop();\n        }\n\n        require(sent, \"Failed to send Ether\");\n\n        emit ConfirmedAttendee(eventId, attendee);\n    }\n\n    // Confirm all the attendees at once\n    function confirmAllAttendees(bytes32 eventId) external {\n        // look up event from our struct with the eventId\n        CreateEvent memory myEvent = idToEvent[eventId];\n\n        // make sure you require that msg.sender is the owner of the event\n        require(msg.sender == myEvent.eventOwner, \"NOT AUTHORIZED\");\n\n        // confirm each attendee in the rsvp array\n        for (uint8 i = 0; i < myEvent.confirmedRSVPs.length; i++) {\n            confirmAttendee(eventId, myEvent.confirmedRSVPs[i]);\n        }\n    }\n\n    function withdrawUnclaimedDeposits(bytes32 eventId) external {\n        // look up event\n        CreateEvent storage myEvent = idToEvent[eventId];\n\n        // check that the paidOut boolean still equals false AKA the money hasn't already been paid out\n        require(!myEvent.paidOut, \"ALREADY PAID\");\n\n        // check if it's been 7 days past myEvent.eventTimestamp\n        require(block.timestamp >= (myEvent.eventTimestamp + 7 days), \"TOO EARLY\");\n\n        // only the event owner can withdraw\n        require(msg.sender == myEvent.eventOwner, \"MUST BE EVENT OWNER\");\n\n        // calculate how many people didn't claim by comparing\n        uint256 unclaimed = myEvent.confirmedRSVPs.length - myEvent.claimedRSVPs.length;\n\n        uint256 payout = unclaimed * myEvent.deposit;\n\n        // mark as paid before sending to avoid reentrancy attack\n        myEvent.paidOut = true;\n\n        // send the payout to the owner\n        (bool sent, ) = msg.sender.call{value: payout}(\"\");\n\n        // if this fails\n        if (!sent) {\n            myEvent.paidOut = false;\n        }\n\n        require(sent, \"Failed to send Ether\");\n\n        emit DepositsPaidOut(eventId);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}